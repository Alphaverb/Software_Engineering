# Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнила:
- Плясунова Милена Юрьевна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | 
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

Работу проверил:
- к.э.н., доцент Панов М.А.

# Лабораторные работы
## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
class Ivan:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"

person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)

person2.surname = 'Петров'
```

### Результат.
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/L91.png)

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print('Обычное мороженое')

icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```

### Результат.
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/L92.png)

## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        return self._value

    def del_value(self):
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value")

obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```

### Результат.
Проблема в коде связана с тем, что метод del_value используется для удаления атрибута _value, но при этом происходит обращение к этому атрибуту в методе get_value. После удаления атрибута его уже не существует, и поэтому возникает ошибка AttributeError.
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/L93.png)

## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    className = 'Mammal'

class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```

### Результат.
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/L94.png)

## Лабораторная работа №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```

### Результат.
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/L95.png)

# Самостоятельные работы
## Самостоятельная работа №1
### Задание "Садовник и помидоры"

### Классовая структура:
### Есть Помидор со следующими характеристиками:
- Индекс
- Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)

### Помидор может:
- Расти (переходить на следующую стадию созревания)
- Предоставлять информацию о своей зрелости

### Есть Куст с помидорами, который:
- Содержит список томатов, которые на нем растут
### А также может:
- Расти вместе с томатами
- Предоставлять информацию о зрелости всех томатов
- Предоставлять урожай

### И также есть Садовник, который имеет:
- Имя
- Растение, за которым он ухаживает
### Он может:
- Ухаживать за растением
- Собирать с него урожай

### Задание:
### Класс Tomato:
1) Создайте класс Tomato
2) Создайте статическое свойство states, которое будет содержать все
стадии созревания помидора
3) Создайте метод __init__(), внутри которого будут определены два
динамических свойства: _index (передается параметром) и _state
(принимает первое значение из словаря states). После написания
этого блока кода в комментарии к нему укажите какими являются
эти два свойства
4) Создайте метод grow(), который будет переводить томат на
следующую стадию созревания
5) Создайте метод is_ripe(), который будет проверять, что томат созрел
   
### Класс TomatoBush:
1) Создайте класс TomatoBush
2) Определите метод __init__(), который будет принимать в качестве
параметра количество томатов и на его основе будет создавать
список объектов класса Tomato. Данный список будет храниться
внутри динамического свойства tomatoes
3) Создайте метод grow_all(), который будет переводить все объекты
из списка томатов на следующий этап созревания
4) Создайте метод all_are_ripe(), который будет возвращать True, если
все томаты из списка стали спелыми.
5) Создайте метод give_away_all(), который будет чистить список
томатов после сбора урожая

### Класс Gardener:
1) Создайте класс Gardener
2) Создайте метод __init__(), внутри которого будут определены два
динамических свойства: name (передается параметром, является
публичным) и _plant (принимает объект класса TomatoBush). После
написания этого блока кода в комментарии к нему укажите какими
являются эти два свойства
3) Создайте метод work(), который заставляет садовника работать, что
позволяет растению становиться более зрелым
4) Создайте метод harvest(), который проверяет, все ли плоды созрели.
Если все, то садовник собирает урожай. Если нет, то метод печатает
предупреждение
5) Создайте статический метод knowledge_base(), который выведет в
консоль справку по садоводству

### Тесты:
1) Вызовите справку по садоводству
2) Создайте объекты классов TomatoBush и Gardener
3) Используя объект класса Gardener, поухаживайте за кустом с
помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели.
Продолжайте ухаживать за ними
5) Соберите урожай
Результатом работы вашей программы будет листинг кода с подробными
комментариями и скриншоты выполнения всех тестов.

```python
class Tomato:
    states = {'Отсутствует': 0, 'Цветение': 1, 'Зеленый': 2, 'Красный': 3}

    def __init__(self, index):
        self._index = index
        self._state = self.states['Отсутствует']

    def grow(self):
        if self._state < 3:
            self._state += 1

    def is_ripe(self):
        return True if self._state == 3 else False

class TomatoBush:
    def __init__(self, num):
        self.tomatoes = [Tomato(index) for index in range(1, num + 1)]

    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        return all([tomato.is_ripe() for tomato in self.tomatoes])

    def give_away_all(self):
        self.tomatoes = []

class Gardener:
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant

    def work(self):
        self._plant.grow_all()

    def harvest(self):
        if self._plant.all_are_ripe():
            print('Урожай собран!')
            self._plant.give_away_all()
        else:
            print('Подождите, томаты еще не дозрели')

    @staticmethod
    def knowledge_base():
        print('Справка по садоводству:\n'
              '1. Выбирайте сорта томатов, подходящие для вашего региона и климата\n'
              '2. Заготовьте плодородную почву с хорошим дренажем. Томаты любят рыхлую почву\n'
              '3. Сажайте рассаду томатов после последнего заморозка\n'
              '4. Регулярно поливайте томаты, особенно в период созревания плодов\n'
              '5. Применяйте удобрения с учетом потребностей томатов в питательных веществах\n'
              '6. Используйте опоры, чтобы поддерживать растения, особенно если у вас высокие сорта томатов\n'
              '7. Проводите обрезку, чтобы удалить лишние листья и побеги\n'
              '8. Регулярно осматривайте растения на наличие вредителей и признаков болезней\n')

Gardener.knowledge_base()

tomato_bush = TomatoBush(5)
gardener = Gardener('Брэд', tomato_bush)
# print(f"Садовник {gardener.name} выращивает {len(tomato_bush.tomatoes)} томат(а/ов)")

gardener.work()
# print(f"Томаты находятся в состоянии: '{list(Tomato.states.keys())[tomato_bush.tomatoes[0]._state]}'")

gardener.work()
gardener.harvest()

gardener.work()
gardener.work()
gardener.work()
gardener.harvest()
```

### Результат.

```python
# Определение класса Tomato
class Tomato:
    # Статический словарь состояний томата
    states = {'Отсутствует': 0, 'Цветение': 1, 'Зеленый': 2, 'Красный': 3}

    # Конструктор объекта томата
    def __init__(self, index):
        self._index = index # Индекс томата
        self._state = self.states['Отсутствует'] # Начальное состояние "Отсутствует"

    # Метод роста томата
    def grow(self):
        if self._state < 3: # Увеличиваем состояние на 1, если оно меньше 3
            self._state += 1

    # Метод проверки зрелости томата
    def is_ripe(self):
        return True if self._state == 3 else False # Возвращает True, если томат созрел (красный)

# Определение класса TomatoBush
class TomatoBush:
    # Конструктор объекта куста томатов
    def __init__(self, num): 
        # Инициализация списка томатов, создание объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num + 1)]

    # Метод роста всех томатов (объектов Tomato)
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    # Метод проверки зрелости всех томатов в кусте
    def all_are_ripe(self):
        return all([tomato.is_ripe() for tomato in self.tomatoes])

    # Метод для сбора всего урожая 
    def give_away_all(self):
        self.tomatoes = [] # Обнуляем список томатов


# Определение класса Gardener
class Gardener:
    # Конструктор объекта садовника
    def __init__(self, name, plant):
        self.name = name # Имя садовника
        self._plant = plant # Растение, за которым ухаживает садовник

    # Метод для работы с растением (ухода за растением)
    def work(self):
        self._plant.grow_all() # Вызов метода grow_all у растения (все томаты растут, увеличивая индекс своего состояния на 1)

    # Метод для сбора урожая
    def harvest(self):
        if self._plant.all_are_ripe(): # Если все томаты созрели, выводим сообщение, собираем урожай и обнуляем список томатов
            print('Урожай собран!')
            self._plant.give_away_all()
        else:
            print('Подождите, томаты еще не дозрели')

    # Статический метод со справкой по садоводству
    @staticmethod
    def knowledge_base():
        print('Справка по садоводству:\n'
              '1. Выбирайте сорта томатов, подходящие для вашего региона и климата\n'
              '2. Заготовьте плодородную почву с хорошим дренажем. Томаты любят рыхлую почву\n'
              '3. Сажайте рассаду томатов после последнего заморозка\n'
              '4. Регулярно поливайте томаты, особенно в период созревания плодов\n'
              '5. Применяйте удобрения с учетом потребностей томатов в питательных веществах\n'
              '6. Используйте опоры, чтобы поддерживать растения, особенно если у вас высокие сорта томатов\n'
              '7. Проводите обрезку, чтобы удалить лишние листья и побеги\n'
              '8. Регулярно осматривайте растения на наличие вредителей и признаков болезней\n')

# Тест статического метода справки
Gardener.knowledge_base()

# Тест создания объектов классов TomatoBush и Gardener 
# Создание куста томатов с 5 томатами
tomato_bush = TomatoBush(5)
# Создание садовника с именем "Брэд" и указанным кустом томатов
gardener = Gardener('Брэд', tomato_bush)
# print(f"Садовник {gardener.name} выращивает {len(tomato_bush.tomatoes)} томат(а/ов)")

# Тест метода работы садовника (увеличение индекса состояния томатов)
gardener.work()
# print(f"Томаты находятся в состоянии: '{list(Tomato.states.keys())[tomato_bush.tomatoes[0]._state]}'")

# Тест метода сбора урожая (так как урожай не созрел, выведется предупреждение)
gardener.work()
gardener.harvest()

# Тест метода сбора урожая (урожай созрел, выведется сообщение об успешном выполнении)
gardener.work()
gardener.work()
gardener.work()
gardener.harvest()
```

#### Тест 1:
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/S911.png)

#### Тест 2:
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/S912.png)

#### Тест 3:
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/S913.png)

#### Тест 4:
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/S914.png)

#### Тест 5:
![Меню](https://github.com/Alphaverb/Software_Engineering/blob/Tema_9/pic/S915.png)

## Выводы

1.  Класс Tomato и метод is_ripe предоставляют пример полиморфизма, поскольку разные объекты (томаты) могут использовать один и тот же метод, но с разными результатами в зависимости от своего состояния.
2.  Защищенные атрибуты создаются путем добавления одного подчеркивания (_) перед именем атрибута или метода. Они используются, когда разработчик хочет запретить доступ снаружи объекта, но дать возможность работать с ними внутри объекта класса-наследника или суперкласса.
3.  Статические методы декларируются при помощи декоратора staticmethod. Им не нужен определённый первый аргумент (ни self, ни cls). Их можно воспринимать как методы, которые "не знают, к какому классу относятся". Таким образом, статические методы прикреплены к классу лишь для удобства и не могут менять состояние ни класса, ни его экземпляра.
